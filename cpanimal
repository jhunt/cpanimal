#!/usr/bin/perl

(my $SCRIPT = $0) =~ s/^.*\///;
use strict;
use warnings;
use Cwd           qw/cwd/;       # core
use POSIX         qw/strftime/;  # core
use Data::Dumper;                # core
use Getopt::Long;                # core
use Archive::Tar;                # core

# {{{ use JSON

my $SRC;
sub _s
{
	my ($i, $s, $a, $b, $l) = (0, "", "", "", length($SRC));

	$b = substr($SRC, $i++, 1);
	if ($b ne '"') {
		while ($i < $l) {
			$a = $b; $b = substr($SRC, $i++, 1);
			if ($a eq '\\') {
				$s .= $b; $a = $b = '';
			} else {
				$s .= $a;
				if ($b eq '"') { $b = ''; last; }
			}
		}
		$s .= $b;
	}
	$SRC = substr($SRC, $i);
	$s;
}
sub _lex
{
	$SRC =~ s/^\s+//;
	return undef unless $SRC;

	return     $1  if $SRC =~ s/^([{}\[\],:])//;
	return [   $1] if $SRC =~ s/^([+-]?[0-9]+(?:\.[0-9]+)?(?:e[+-]?\d+)?)//;
	return [    1] if $SRC =~ s/^true\b//;
	return [    0] if $SRC =~ s/^false\b//;
	return [undef] if $SRC =~ s/^null\b//;
	return [ _s()] if $SRC =~ s/^"//;
	die "Malformed JSON at ".substr($SRC, 0, 140)."\n";
}

sub _decode_hash
{
	my $h = {};
	while (my $t = _lex()) {
		unless (ref $t) {
			next      if $t eq ',';
			return $h if $t eq '}';
			die "Invalid '$t' in hash!\n";
		}
		my $key = $t->[0];

		$t = _lex() or last;
		die "Missing ':' key/value separator!\n" unless $t eq ':';

		$t = _lex() or last;
		if (ref $t)       { $h->{$key} = $t->[0] }
		elsif ($t eq '{') { $h->{$key} = _decode_hash() }
		elsif ($t eq '[') { $h->{$key} = _decode_list() }
		else { die "Unexpected $t after ':' key/value separator!\n" }
	}
	die "Unexpected end of input string\n";
}

sub _decode_list
{
	my $l = [];
	while (my $t = _lex()) {
		unless (ref $t) {
			next      if $t eq ',';
			return $l if $t eq ']';
		}

		if (ref $t)       { push @$l, $t->[0] }
		elsif ($t eq '{') { push @$l, _decode_hash() }
		elsif ($t eq '[') { push @$l, _decode_list() }
		else { die "Unexpected $t in list!\n" }
	}
	die "Unexpected end of input string\n";
}

sub decode_json
{
	$SRC = $_[0];
	my $t = _lex();
	die "Unexpected end of input string\n" if !!! $t;
	die "Invalid literal at top-level!\n"  if ref $t;

	return _decode_hash() if $t eq '{';
	return _decode_list() if $t eq '[';

	die "Invalid '$t' at top-level!\n";
}
# }}}
# {{{ ANSI coloring
my %C = (
	x      => "\x1b[0m",
	black  => "\x1b[30;0m",
	red    => "\x1b[31m",
	green  => "\x1b[32m",
	yellow => "\x1b[33m",
	blue   => "\x1b[34m",
	purple => "\x1b[35m",
	cyan   => "\x1b[36m",
	white  => "\x1b[37m",
);
unless (-t STDOUT) {
	$C{$_} = '' for keys %C;
}
# }}}
# {{{ Options Processing

sub usage
{
	print "USAGE: $SCRIPT  OPTIONS  COMMAND  [MODULE [MODULE ...]]\n";
	return 0;
}

my %OPTIONS = (
	root      => cwd,
	template  => undef,
	tests     => 1,
	prefix    => 'perl',
	overrides => '/etc/cpanimal/overides.conf',
	debug     => $ENV{DEBUG},
);
sub debug
{
	print "$C{purple}+++ $_[0]$C{x}\n" if $OPTIONS{debug};
}
sub rcfiles
{
	for my $file (@_) {
		debug "trying rc file $file";
		next unless -f $file;
		debug "parsing rc file $file";
		open my $fh, "<", $file or die "Failed to open $file: $!\n";
		while (<$fh>) {
			chomp;
			s/\s*#.*//;
			next unless m/^(\S+)\s+(.*)/;
			if (exists $OPTIONS{$1}) {
				$OPTIONS{$1} = $2;
				next;
			}
			warn "Ignoring unknown configuration option '$1'\n";
		}
		close $fh;
	}
}
rcfiles("$ENV{HOME}/.cpanimalrc", "/etc/cpanimal/cpanimalrc");
$OPTIONS{root} =~ s!^~/!$ENV{HOME}/!;
for (qw/tests strict/) {
	next unless defined $OPTIONS{$_};
	$OPTIONS{$_} = 1 if $OPTIONS{$_} =~ m/^ye/i; # yes, yeah, yessir...
	$OPTIONS{$_} = 0 if $OPTIONS{$_} =~ m/^no/i; # no, nope, not!, no way jos√©...
}
GetOptions(\%OPTIONS, qw/
	help|h|?
	debug|D

	prefix=s
	root=s
	tests!
	overrides=s
	strict!
/) or exit usage();
if ($OPTIONS{strict}) {
	my $n = 0;
	unless ($ENV{PACKAGER_NAME}) {
		print STDERR "\$PACKAGER_NAME environment variable is not set.\n";
		$n++;
	}
	unless ($ENV{PACKAGER_EMAIL}) {
		print STDERR "\$PACKAGER_EMAIL environment variable is not set.\n";
		$n++;
	}
	unless ($ENV{HOME}) {
		print STDERR "\$HOME environment variable is not set.\n";
		$n++;
	}

	if ($n) {
		print STDERR "\nstrict mode failures detected!!\nPlease fix and try again.\n";
		exit 2;
	}
}

sub read_DATA
{
	my (@blocks, @s);
	while (<DATA>) {
		if (m/^__DATA__$/ and @s) {
			push @blocks, join('', @s);
			@s = ();
		} else {
			push @s, $_;
		}
	}
	close DATA;
	return @blocks;
}

my ($embedded_SPEC, $PERL_PROVIDES, $PERL_REQUIRES) = read_DATA;
my $SPEC;
if (defined $OPTIONS{template}) {
	open my $tpl, "<", $OPTIONS{template}
		or die "$OPTIONS{template}: $!\n";
	$SPEC = do { local $/; <$tpl> };
	close $tpl;
} else {
	$SPEC = $embedded_SPEC;
	$OPTIONS{template} = '<embedded>';
}

my $PWD = cwd;
my $SUDO = ($< == 0 ? '' : 'sudo ');
my %SEEN = ();
my %HAVE = ( perl => 1 );

# }}}
# {{{ Helper utilities
sub bail
{
	my ($msg, @rest) = @_;
	die $msg."\n".Dumper(@rest) if $ENV{DEBUG};
	die $msg."\n(re-run with DEBUG=1 in your environment for diagnostics)\n";
}

sub run
{
	my ($command) = @_;
	print "$C{yellow}+ $command$C{x}\n";
	qx($command);
}

sub runlog
{
	my ($command) = @_;
	print "$C{yellow}+ $command$C{x}\n";
	qx($command >$OPTIONS{root}/.lastlog 2>&1);
	dump_log('black') if $OPTIONS{debug};
}

my $QUIET = 0;
sub stage
{
	print "$C{cyan}####   $_[0]   ####$C{x}\n" unless $QUIET;
}

sub step
{
	print "$C{green}>> $_[0]$C{x}\n" unless $QUIET;
}

sub lookup
{
	my ($name) = @_;
	if (-f "$OPTIONS{root}/.cache/$name") {
		open my $fh, "<", "$OPTIONS{root}/.cache/$name";
		if ($fh) {
			my $v = decode_json(do { local $/; <$fh> });
			close $fh;
			return $v;
		}
		warn "Failed to open cache file: $OPTIONS{root}/.cache/$name; contactin API\n";
	}

	my $url = "http://api.metacpan.org";

	step "retrieving $url/module/$name";
	my $json = qx(curl -q $url/module/$name 2>/dev/null);
	$? == 0 or return undef;

	my $module = decode_json($json);
	$module->{message} and die "error: $module->{message}\n";
	$module->{distribution}
		or bail "No distribution found in module metadata!\n".
		        "Either this module is corrupt, or $SCRIPT needs some TLC...\n", $module;

	step "retrieving $url/release/$module->{distribution}";
	$json = qx(curl -q $url/release/$module->{distribution} 2>/dev/null);
	$? == 0 or return undef;

	if (-d "$OPTIONS{root}/.cache") {
		open my $fh, ">", "$OPTIONS{root}/.cache/$name";
		if ($fh) {
			print $fh $json;
			close $fh;
		} else {
			warn "Unable to open cache file $OPTIONS{root}/.cache/$name for writing: $!\n";
		}
	}
	my $rel = decode_json($json);
	$rel->{message} and die "error: $rel->{message}\n";
	$rel->{distribution}
		or bail "No distribution found in release metadata!\n".
		        "Either this module is corrupt, or $SCRIPT needs some TLC...\n", $rel;
	$rel;
}

sub deps
{
	my ($rel) = @_;

	my (@requires, @build_requires);
	for my $dep (@{ $rel->{dependency} }) {
		next if $dep->{phase}        eq 'develop';
		next if $dep->{phase}        eq 'test' and !$OPTIONS{tests};
		next if $dep->{relationship} ne 'requires';

		if ($dep->{phase} =~ m/^(configure|test|build)/) {
			push @build_requires, $dep;
		} else {
			push @requires,       $dep;
		}
	}

	return \@requires, \@build_requires;
}

sub req_name
{
	my ($mod, $ver) = @_;
	$mod = "perl($mod)" unless $mod eq 'perl';
	$ver ? "$mod >= $ver" : $mod;
}

sub reqs
{
	my ($tag, $list) = @_;
	if (!$list) {
		$list = $tag;
		$tag = '';
	}
	join('', map {
		sprintf("%-15s %s\n", "${tag}Requires:",
			req_name($_->{module}, $_->{version}))
	} @$list);
}

chomp(my $ARCH = qx(uname -m));
sub module_arch
{
	my ($archive) = @_;
	my $tar = Archive::Tar->new;
	$tar->read($archive);

	for ($tar->list_files()) {
		return $ARCH if m/\.(xs|c|cpp)$/;
	}
	return 'noarch';
}

sub archive_root_dir
{
	my ($archive, @try) = @_;
	my $tar = Archive::Tar->new;
	$tar->read($archive);

	debug "determining dist archive root directory...";
	for (@try) {
		debug "trying $_";
		return $_ if $tar->contains_file("$_")
		          or $tar->contains_file("$_/")
		          or $tar->contains_file("$_/MANIFEST")
		          or $tar->contains_file("$_/Makefile.PL")
		          or $tar->contains_file("$_/Build.PL");
	}
	debug "is it one of these?";
	debug "  $_" for grep { !m{/.+/} } $tar->list_files;
	die "Unable to determine root directory for $try[0] archive $archive\n";
}

sub specfile
{
	my ($file, $rel, $requires, $build_requires) = @_;
	open my $spec, ">", $file
		or die "Failed to open $file for writing: $!\n";

	my $url = $rel->{download_url};
	(my $tarball = $url) =~ s!.*/!!;
	if (!-f "$OPTIONS{root}/SOURCES/$tarball") {
		step "downloading $url";
		run qq(curl $url > $OPTIONS{root}/SOURCES/$tarball);
		$? == 0 or die "Failed.\n";
	} else {
		step "using pre-existing $tarball";
	}
	my $arch = module_arch("$OPTIONS{root}/SOURCES/$tarball");

	my $PREFIX = $OPTIONS{prefix};
	$PREFIX = "$PREFIX-" unless $PREFIX =~ m/-$/;
	$PREFIX = '' if $rel->{distribution} eq 'mod_perl';

	my $relname = $rel->{name};
	my $version = $relname; $version =~ s/.*-//;
	my $archive_root = archive_root_dir("$OPTIONS{root}/SOURCES/$tarball",
		$relname, $rel->{distribution});

	my $overrides = parse_overrides_files(
		$OPTIONS{overrides},
		'/etc/cpanimal/overrides.conf',
		"$ENV{HOME}/.cpanimal.overrides");

	my %tokens = (
		VERSION        => $version,
		DISTNAME       => $rel->{distribution},
		RPMPREFIX      => $PREFIX,
		RPMFILE        => $PREFIX.$relname."-1.$arch.rpm",
		SUMMARY        => $rel->{abstract} || "Perl $rel->{distribution}, you know, from CPAN??",
		DESCRIPTION    => $rel->{abstract} || "Perl $rel->{distribution}, you know, from CPAN??",
		URL            => $rel->{download_url},
		PACKAGER_NAME  => $ENV{PACKAGER_NAME}  ||  $ENV{USER}                  || '(nobody)',
		PACKAGER_EMAIL => $ENV{PACKAGER_EMAIL} || "$ENV{USER}\@$ENV{HOSTNAME}" || 'none',
		DATE           => strftime("%a %b %d %Y", localtime(time)),
		REQUIRES       => reqs($requires),
		BUILDREQUIRES  => reqs('Build', $build_requires),
		BUILDARCH      => $arch,
		ARCHIVE_ROOT   => $archive_root,
		PATCHED_PERL_PROVIDES => $PERL_PROVIDES,
		PATCHED_PERL_REQUIRES => $PERL_REQUIRES,

		overrides($rel, $overrides),
	);
	my $x = "$SPEC";
	$x =~ s/\{\{$_\}\}/$tokens{$_}/eg for keys %tokens;
	print $spec $x;
	close $spec;

	return %tokens;
}

sub dump_log
{
	open my $log, "<", "$OPTIONS{root}/.lastlog"
		or return;
	my $contents = do { local $/; <$log> };
	close $log;

	if ($contents) {
		print $C{$_[0] || 'red'}; print "-" x 80; print "\n";
		print $contents;
		print "-" x 80; print "\n"; print $C{x};
	}

	if ($OPTIONS{debug}) {
		print $C{$_[0] || 'red'};
		print "  Module state dump:\n";
		print "  - have '$_'\n" for sort keys %HAVE;
		print $C{x};
	}
}

sub check_log
{
	my ($re) = @_;
	open my $fh, "<", "$OPTIONS{root}/.lastlog" or return undef;
	while (local $_ = <$fh>) {
		next unless m/$re/;
		close $fh; return 1;
	}
	close $fh; return undef;
}

sub grep_log
{
	my ($re) = @_;
	my @l;
	open my $fh, "<", "$OPTIONS{root}/.lastlog" or return;
	while (<$fh>) {
		push @l, $1 if m/$re/;
	}
	close $fh;
	return @l;
}

sub have_module
{
	my ($mod, $ver) = @_;
	return 1 if $HAVE{$mod};    # FIXME: handle version deps

	if ($mod ne 'Module::Runtime' and have_module('Module::Runtime')) {
		runlog qq|perl -MModule::Runtime=use_module -e 'use_module("$mod");'|;
	} else {
		runlog qq|perl -M$mod -e 'exit 0;'|;
	}
	return ($HAVE{$mod} = ($? == 0));
}

sub setup
{
	qx(mkdir -p $OPTIONS{root});
	qx(mkdir -p $OPTIONS{root}/$_)
		for qw/ RPMS SRPMS SOURCES SPECS BUILD .cache /
}

# }}}
# {{{ Overrides handling

sub parse_overrides_files
{
	for (@_) {
		return parse_overrides_file($_) if -f $_;
	}
}

sub parse_overrides_file
{
	my ($path) = @_;
	open my $fh, "<", $path
		or return {};
	my $over = parse_overrides_io($fh);
	close $fh;
	$over;
}

sub parse_overrides_io
{
	my ($io) = @_;
	my @lines;
	while (<$io>) {
		chomp;
		s/\s*#.*$//;
		s/;/ ; /g;
		push @lines, $_;
	}

	my %over;
	my @tokens = grep { length $_ } split(/\s+/, join(' ', @lines));
	while (@tokens) {
		my $pkg    = shift @tokens or die "Unexpected end of input\n";
		next if $pkg eq ';'; # allow multiple semi-colons
		my $action = shift @tokens or die "Unexpected end of input\n";
		my $key    = shift @tokens or die "Unexpected end of input\n";

		if ($action =~ m/^(skip|run)$/ and $key eq 'tests') {
			$over{$pkg}{run_tests} = ($action eq 'run' ? 1 : 0);

		} elsif ($action =~ m/^(skip|add)$/) {
			my @values;
			while (@tokens) {
				my $t = shift @tokens;
				last if $t eq ';';
				push @values, $t;
			}
			@values or die "Unexpected end of input\n";

			$key =~ m/^(build_requires|requires|provides|files)$/
				or die "Unrecognized key '$key'\n(you want 'requires', 'build_requires', 'provides' or 'files')\n";

			die "'add files' is not supported at this time.\n"
				if $action eq 'add' and $key eq 'files';

			$over{$pkg}{$action}{$key} ||= [];
			push @{ $over{$pkg}{$action}{$key} }, @values;

		} elsif ($action eq 'prefer') {
			$over{$pkg}{$action} = $key;

		} elsif ($action =~ m/^(pre|post)-(prep|check|build|install|clean)$/) {
			$key eq '{' or die "Unexpected token '$key', expecting block delimiter '{'\n";
			my @block;
			while (@tokens) {
				my $t = shift @tokens;
				last if $t eq '}';
				push @block, $t;
			}
			# NOTE: this makes non-semicolon bash style not work...
			#       since the newlines are effectively removed.
			$over{$pkg}{$action} = join ' ', @block;

		} else {
			die "Unrecognized action '$action'\n(you want 'skip', 'add' or 'prefer')\n";
		}
	}
	return \%over;
}

sub overrides
{
	my ($rel, $overrides) = @_;
	my %o = ();

	my $combined = {
		prefer    => 'Makefile.PL',
		run_tests => $OPTIONS{tests},
	};
	for my $top ($rel->{distribution}, '*') {
		for my $action (qw/add skip/) {
			for my $type (qw/requires build_requires provides files/) {
				$combined->{$action}{$type} ||= [];
				push @{$combined->{$action}{$type}}, @{$overrides->{$top}{$action}{$type}}
					if exists $overrides->{$top}{$action}{$type};
			}
		}
		for my $phase (glob '{pre,post}-{prep,check,build,install,clean}') {
			$combined->{$phase} ||= [];
			next unless exists $overrides->{$top}{$phase};
			push @{$combined->{$phase}}, $overrides->{$top}{$phase};
		}
		for my $single (qw/prefer run_tests/) {
			next unless exists $overrides->{$top}{$single};
			$combined->{$single} = $overrides->{$top}{$single};
		}
	};

	$o{OVERRIDE_ADD_REQUIRES} =
		join "\n", map { "Requires:      $_" } @{ $combined->{add}{requires} };
	$o{OVERRIDE_ADD_BUILDREQUIRES} =
		join "\n", map { "BuildRequires: $_" } @{ $combined->{add}{build_requires } };
	$o{OVERRIDE_ADD_PROVIDES} =
		join "\n", map { "Provides:      $_" } @{ $combined->{add}{provides } };

	$o{OVERRIDE_SKIP_REQUIRES} =
		join "\n", map { "  sed -e '". (m{^/.*/$} ? $_ : "/^$_\$/") . "d' |\\" }
			@{ $combined->{skip}{requires} };
	$o{OVERRIDE_SKIP_PROVIDES} =
		join "\n", map { "  sed -e '". (m{^/.*/$} ? $_ : "/^$_\$/") . "d' |\\" }
			@{ $combined->{skip}{provides} };
	$o{OVERRIDE_SKIP_FILES} =
		join "\n", map { 'find $RPM_BUILD_ROOT '.
				( m{^/(.*)/$}
				? "-regextype posix-extended -regex '.*$1.*'"
				: "-path '$_'" ). ' -exec rm -f {} \\;';
			} @{ $combined->{skip}{files} };

	$o{PREFER}    = $combined->{prefer};
	$o{RUN_TESTS} = $combined->{run_tests};

	$o{OVERRIDE_PRE_PREP}     = join "\n", @{ $combined->{'pre-prep'}     };
	$o{OVERRIDE_POST_PREP}    = join "\n", @{ $combined->{'post-prep'}    };

	$o{OVERRIDE_PRE_CHECK}    = join "\n", @{ $combined->{'pre-check'}    };
	$o{OVERRIDE_POST_CHECK}   = join "\n", @{ $combined->{'post-check'}   };

	$o{OVERRIDE_PRE_BUILD}    = join "\n", @{ $combined->{'pre-build'}    };
	$o{OVERRIDE_POST_BUILD}   = join "\n", @{ $combined->{'post-build'}   };

	$o{OVERRIDE_PRE_INSTALL}  = join "\n", @{ $combined->{'pre-install'}  };
	$o{OVERRIDE_POST_INSTALL} = join "\n", @{ $combined->{'post-install'} };

	$o{OVERRIDE_PRE_CLEAN}    = join "\n", @{ $combined->{'pre-clean'}    };
	$o{OVERRIDE_POST_CLEAN}   = join "\n", @{ $combined->{'post-clean'}   };

	%o;
}

# }}}

sub spec
{
	my ($name) = @_;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};
	my ($requires ,$build_requires) = deps($rel);

	my $specfile = "$OPTIONS{root}/SPECS/$dist.spec";
	specfile($specfile, $rel, $requires, $build_requires);
	step "wrote spec file for $name to $specfile";
}

sub source
{
	my ($name) = @_;
	stage "Getting source for $name";
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};

	my $url = $rel->{download_url};
	(my $file = $url) =~ s!.*/!!;
	step "downloading $url";
	run qq(curl $url > $OPTIONS{root}/SOURCES/$file);
	print "\n";
	$? == 0 or die "$name Failed.\n";
}

sub info
{
	my ($name) = @_;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";

	print <<EOF;
============================== $name
$rel->{distribution} $rel->{version} by $rel->{author} 
  $rel->{download_url}
  $rel->{status} / $rel->{maturity} (tests: $rel->{tests}{pass}/$rel->{tests}{fail}/$rel->{tests}{unknown}/$rel->{tests}{unknown}  pass/fail/unknown/na)

$rel->{abstract}

EOF
	if ($rel->{provides}) {
		print "Provides:\n";
		print "  - $_\n" for sort @{ $rel->{provides} };
	} else {
		print "Provides: none\n";
	}
	print "\n";
	if ($rel->{dependency}) {
		print "Prereqs:\n";
		for (@{ $rel->{dependency} }) {
			print "  - $_->{phase} $_->{relationship} $_->{module} ($_->{version})\n"
				if  $_->{version};
			print "  - $_->{phase} $_->{relationship} $_->{module}\n"
				if !$_->{version};
		}
	} else {
		print "Prereqs: none\n";
	}
	print "\n";
}

sub deptree
{
	my ($name, $prefix) = @_;
	$prefix ||= '';
	return if $HAVE{$name};
	$HAVE{$name} = 1;

	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};
	return if $dist =~ m/^perl$/;
	my ($requires ,$build_requires) = deps($rel);

	for (@$build_requires) {
		print "$prefix$name $_->{phase} $_->{relationship} $_->{module}\n";
		deptree($_->{module}, "$prefix  ");
	}
	for (@$requires) {
		print "$prefix$name $_->{phase} $_->{relationship} $_->{module}\n";
		deptree($_->{module}, "$prefix  ");
	}
}

sub arch
{
	my ($name) = @_;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};

	my $url = $rel->{download_url};
	(my $file = $url) =~ s!.*/!!;
	if (! -f "$OPTIONS{root}/SOURCES/$file") {
		step "downloading $url";
		run qq(curl $url > $OPTIONS{root}/SOURCES/$file);
		print "\n";
		$? == 0 or die "$name Failed.\n";
	}

	my $arch = module_arch("$OPTIONS{root}/SOURCES/$file");
	print "$name is $arch\n";
}

sub build_all
{
	for (@_) {
		my ($mod, $ver);
		if (ref $_) {
			$mod = $_->{module};
			$ver = $_->{version};
		} else {
			$mod = $_;
		}
		build($mod, $ver) unless have_module($mod);
	}
}

sub build
{
	my ($name) = @_;
	die "refusing to build '$name'!\n" if $name =~ m/^perl$/;
	stage "Building $name";

	$SEEN{$name} = 1;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};
	die "refusing to build '$dist'!\n" if $dist =~ m/^perl$/;
	my ($requires ,$build_requires) = deps($rel);

	for my $dep (@$build_requires, @$requires) {
		print "   $C{green}$name $dep->{relationship} $dep->{module} (for $dep->{phase})$C{x}\n";
		if (!have_module($dep->{module}, $dep->{version})) {
			die "Module dependency loop detected; I have no idea what to do now...\n"
				if $SEEN{$dep->{module}};

			step "dependent module $dep->{module} needs built";
			build($dep->{module});
		}
	}

	my $specfile = "$OPTIONS{root}/SPECS/$dist.spec";
	my %tokens = specfile($specfile, $rel, $requires, $build_requires);
	step "wrote spec file for $name to $specfile";

	my $tarball = $tokens{URL}; $tarball =~ s!.*/!!;
	my $arch = module_arch("$OPTIONS{root}/SOURCES/$tarball");

	step "building RPM package";
	runlog qq(rpmbuild -ba -D "_topdir $OPTIONS{root}" $specfile </dev/null);
	if ($? != 0) {
		if (!check_log(qw/ is needed by/)) {
			dump_log;
			die "$name Failed.\n";
		}
		# check the log for perl(...) build deps

		step "building missing build dependencies";
		build_all grep_log(qr/perl\((.*?)\) .*is needed by/);
		for (grep_log(qr/^\s*(\S+)\s.*is needed by/)) {
			next if m/^perl\(/;
			runlog qq($SUDO yum install -y $_);
		}

		# try the build again
		step "retrying RPM package build";
		runlog qq(rpmbuild -ba -D "_topdir $OPTIONS{root}" $specfile </dev/null);
		if ($? != 0) {
			dump_log;
			die "$name Failed.\n";
		}
		run qq|ls -lh $tokens{RPMFILE}|;
	}

	step "building runtime / installation dependencies";
	build_all @$requires;

	step "installing RPM package";
	runlog qq($SUDO rpm -U $OPTIONS{root}/RPMS/$arch/$tokens{RPMFILE});
	if ($? != 0) {
		# check the log for perl(...) deps
		unless (check_log(qr/is already installed/)) {
			# build the new deps
			step "building missed dependencies";
			build_all grep_log(qr/perl\((.*?)\) .*is needed by/);

			# try the install again
			step "retrying RPM package installation";
			runlog qq($SUDO rpm -U $OPTIONS{root}/RPMS/$arch/$tokens{RPMFILE});
			if ($? != 0) {
				dump_log;
				die "$name Failed\n";
			}
		} else {
			print "... looks like $name is already installed?\n";
			dump_log 'purple';
		}
	}

	print "\n\n";
	$HAVE{$name} = 1;
	delete $SEEN{$name};
}
if (!@ARGV) {
	exit usage();

} elsif ($ARGV[0] eq 'config') {
	printf "%10s: %s\n", $_, $OPTIONS{$_} for sort keys %OPTIONS;

} elsif ($ARGV[0] eq 'spec') {
	shift @ARGV;
	setup;
	spec $_ for @ARGV;

} elsif ($ARGV[0] eq 'source') {
	shift @ARGV;
	setup;
	source $_ for @ARGV;

} elsif ($ARGV[0] eq 'info') {
	shift @ARGV;
	info $_ for @ARGV;

} elsif ($ARGV[0] eq 'dump') {
	shift @ARGV;
	for (@ARGV) {
		my $rel = lookup($_) or next;
		print Dumper($_ => $rel);
		print "\n\n";
	}

} elsif ($ARGV[0] eq 'deptree') {
	shift @ARGV;
	$QUIET = 1;
	deptree $_ for @ARGV;
	print "\n\n";
	print "Total modules: ".scalar(keys %HAVE)."\n";

} elsif ($ARGV[0] eq 'arch') {
	shift @ARGV;
	setup;
	arch $_ for @ARGV;

} elsif ($ARGV[0] eq 'build') {
	shift @ARGV;
	setup;
	build_all 'Module::Runtime'; # my deps
	build_all @ARGV;

} elsif ($ARGV[0]) {
	setup;
	build_all 'Module::Runtime'; # my deps
	build_all @ARGV;

} else {
	print STDERR "USAGE: $0 (spec|source|info|build) Module::Name\n";
	exit 1;
}

__DATA__
# generated by cpanimal
%define __cpanimal_filelist %{_tmppath}/%{name}-%{version}-filelist
%define __cpanimal_run_tests {{RUN_TESTS}}

Name:           {{RPMPREFIX}}{{DISTNAME}}
Obsoletes:      {{RPMPREFIX}}{{DISTNAME}}
Provides:       {{RPMPREFIX}}{{DISTNAME}}
Version:        {{VERSION}}
Release:        1%{?_dist}
Summary:        {{SUMMARY}}
URL:            {{URL}}
License:        distributable
Group:          Development/Libraries

BuildRoot:      %{_tmppath}/%{name}-root
BuildArch:      {{BUILDARCH}}
Source0:        {{URL}}

{{BUILDREQUIRES}}
{{OVERRIDE_ADD_BUILDREQUIRES}}
{{REQUIRES}}
{{OVERRIDE_ADD_REQUIRES}}

%description
{{DESCRIPTION}}

##########################################################
%prep
%setup -q -n {{ARCHIVE_ROOT}}
{{OVERRIDE_PRE_PREP}}

%define __perl_provides %{_builddir}/patched-perl-provides
cat > %{__perl_provides} <<'END_PATCHED'
{{PATCHED_PERL_PROVIDES}}
END_PATCHED
chmod +x %{__perl_provides}

%define __new_perl_provides %{_builddir}/cpan-perl-provides
cat > %{__new_perl_provides} <<END_PROVIDES
#!/bin/sh
# drop bad 'Provides' symbols
%{__perl_provides} $* |\
  sed -e 's/\s+$//' |\
{{OVERRIDE_SKIP_PROVIDES}}
  cat
END_PROVIDES
chmod +x %{__new_perl_provides}
%define __perl_provides %{__new_perl_provides}
%define __find_provides %{__new_perl_provides}

%define __perl_requires %{_builddir}/patched-perl-requires
cat > %{__perl_requires} <<'END_PATCHED'
{{PATCHED_PERL_REQUIRES}}
END_PATCHED
chmod +x %{__perl_requires}

%define __new_perl_requires %{_builddir}/cpan-perl-requires
cat > %{__new_perl_requires} <<END_REQUIRES
#!/bin/sh
# drop bad 'Requires' symbols
%{__perl_requires} $* |\
  sed -e 's/\s+$//' |\
{{OVERRIDE_SKIP_REQUIRES}}
  cat
END_REQUIRES
chmod +x %{__new_perl_requires}
%define __perl_requires %{__new_perl_requires}
%define __find_requires %{__new_perl_requires}

{{OVERRIDE_POST_PREP}}


##########################################################
%build
{{OVERRIDE_PRE_BUILD}}
if [[ "x{{PREFER}}" == "xMakefile.PL" ]]; then
  if [[ -f Makefile.PL ]]; then
    CFLAGS="$RPM_OPT_FLAGS" \
    PERL_AUTOINSTALL='--skipdeps' \
      perl Makefile.PL INSTALLDIRS=vendor
    make

  elif [[ -f Build.PL ]]; then
    CFLAGS="$RPM_OPT_FLAGS" \
    PERL_AUTOINSTALL='--skipdeps' \
      perl Build.PL
    ./Build

  else
    echo "Error: No Makefile.PL or Build.PL found!!"
    exit 1
  fi

elif [[ "x{{PREFER}}" == "xBuild.PL" ]]; then
  if [[ -f Build.PL ]]; then
    CFLAGS="$RPM_OPT_FLAGS" \
    PERL_AUTOINSTALL='--skipdeps' \
      perl Build.PL
    ./Build

  elif [[ -f Makefile.PL ]]; then
    CFLAGS="$RPM_OPT_FLAGS" \
    PERL_AUTOINSTALL='--skipdeps' \
      perl Makefile.PL INSTALLDIRS=vendor
    make

  else
    echo "Error: No Makefile.PL or Build.PL found!!"
    exit 1
  fi

else
  echo "Error: preferred build system '{{PREFER}}' unrecognized!"
  exit 1
fi

{{OVERRIDE_POST_BUILD}}


##########################################################
%check
{{OVERRIDE_PRE_CHECK}}
%if %{__cpanimal_run_tests}
if [[ "x{{PREFER}}" == "xMakefile.PL" ]]; then
  if [[ -f Makefile.PL ]]; then
    make test

  elif [[ -f Build.PL ]]; then
    ./Build test

  else
    echo "Error: No Makefile.PL or Build.PL found!!"
    exit 1
  fi

elif [[ "x{{PREFER}}" == "xBuild.PL" ]]; then
  if [[ -f Build.PL ]]; then
    ./Build test

  elif [[ -f Makefile.PL ]]; then
    make test

  else
    echo "Error: No Makefile.PL or Build.PL found!!"
    exit 1
  fi

else
  echo "Error: preferred build system '{{PREFER}}' unrecognized!"
  exit 1
fi
%endif

{{OVERRIDE_POST_CHECK}}


##########################################################
%clean
{{OVERRIDE_PRE_CLEAN}}

rm -rf $RPM_BUILD_ROOT

{{OVERRIDE_POST_CLEAN}}


##########################################################
%install
{{OVERRIDE_PRE_INSTALL}}

rm -rf $RPM_BUILD_ROOT
export PERL5LIB=$(perl -e "print join(':', map { '$RPM_BUILD_ROOT'.\$_ } @INC);")

if [[ "x{{PREFER}}" == "xMakefile.PL" ]]; then
  if [[ -f Makefile.PL ]]; then
    make install DESTDIR=$RPM_BUILD_ROOT

  elif [[ -f Build.PL ]]; then
    ./Build install --installdirs=vendor --destdir=$RPM_BUILD_ROOT

  else
    echo "Error: No Makefile.PL or Build.PL found!!"
    exit 1
  fi

elif [[ "x{{PREFER}}" == "xBuild.PL" ]]; then
  if [[ -f Build.PL ]]; then
    ./Build install --installdirs=vendor --destdir=$RPM_BUILD_ROOT

  elif [[ -f Makefile.PL ]]; then
    make install DESTDIR=$RPM_BUILD_ROOT

  else
    echo "Error: No Makefile.PL or Build.PL found!!"
    exit 1
  fi

else
  echo "Error: preferred build system '{{PREFER}}' unrecognized!"
  exit 1
fi

[ -x /usr/lib/rpm/brp-compress ] && /usr/lib/rpm/brp-compress

{{OVERRIDE_SKIP_FILES}}

find $RPM_BUILD_ROOT \( -name perllocal.pod -o -name .packlist \) -exec rm -v {} \;
find $RPM_BUILD_ROOT/usr -type f -print | \
  sed "s@^$RPM_BUILD_ROOT@@g" > %{__cpanimal_filelist}

if test ! -s %{__cpanimal_filelist}; then
  echo "Error: No files found to package!!"
  exit 1
fi

{{OVERRIDE_POST_INSTALL}}


%files -f %{__cpanimal_filelist}
%defattr(-,root,root)

%changelog
* {{DATE}} {{PACKAGER_NAME}} <{{PACKAGER_EMAIL}}> {{VERSION}}-1
- Initial package, courtesy of cpanimal
__DATA__
#!/usr/bin/perl

# RPM (and it's source code) is covered under two separate licenses.

# The entire code base may be distributed under the terms of the GNU
# General Public License (GPL), which appears immediately below.
# Alternatively, all of the source code in the lib subdirectory of the
# RPM source code distribution as well as any code derived from that
# code may instead be distributed under the GNU Library General Public
# License (LGPL), at the choice of the distributor. The complete text
# of the LGPL appears at the bottom of this file.

# This alternative is allowed to enable applications to be linked
# against the RPM library (commonly called librpm) without forcing
# such applications to be distributed under the GPL.

# Any questions regarding the licensing of RPM should be addressed to
# Erik Troan <ewt@redhat.com>.

# a simple script to print the proper name for perl libraries.

# To save development time I do not parse the perl grammmar but
# instead just lex it looking for what I want.  I take special care to
# ignore comments and pod's.

# it would be much better if perl could tell us the proper name of a
# given script.

# The filenames to scan are either passed on the command line or if
# that is empty they are passed via stdin.

# If there are lines in the file which match the pattern
#      (m/^\s*\$VERSION\s*=\s+/)
# then these are taken to be the version numbers of the modules.
# Special care is taken with a few known idioms for specifying version
# numbers of files under rcs/cvs control.

# If there are strings in the file which match the pattern
#     m/^\s*\$RPM_Provides\s*=\s*["'](.*)['"]/i
# then these are treated as additional names which are provided by the
# file and are printed as well.

# I plan to rewrite this in C so that perl is not required by RPM at
# build time.

# by Ken Estes Mail.com kestes@staff.mail.com
# updated by James Hunt <james@jameshunt.us> for PAUSE shenanigans

if ("@ARGV") {
  foreach (@ARGV) {
    process_file($_);
  }
} else {

  # notice we are passed a list of filenames NOT as common in unix the
  # contents of the file.

  foreach (<>) {
    process_file($_);
  }
}


foreach $module (sort keys %require) {
  if (length($require{$module}) == 0) {
    print "perl($module)\n";
  } else {

    # I am not using rpm3.0 so I do not want spaces arround my
    # operators. Also I will need to change the processing of the
    # $RPM_* variable when I upgrade.

    print "perl($module) = $require{$module}\n";
  }
}

exit 0;



sub process_file {

  my ($file) = @_;
  chomp $file;
  
  open(FILE, "<$file") || return;

  my ($package, $version, $incomment, $inover, $inpause) = ();

  while (<FILE>) {
    
    # skip the documentation

    # we should not need to have item in this if statement (it
    # properly belongs in the over/back section) but people do not
    # read the perldoc.

    if (m/^=(head[1-4]|pod|item)/) {
      $incomment = 1;
    }

    if (m/^=(cut)/) {
      $incomment = 0;
      $inover = 0;
      $inpause = 0;
    }
    
    if (m/^=(over)/) {
      $inover = 1;
    }

    if (m/^=(back)/) {
      $inover = 0;
    }

    if ($incomment || $inover) {
       next;
    }
    
    # skip the data section
    if (m/^__(DATA|END)__$/) {
      last;
    }

    if (m/^\s*package\s*(#.*)?$/) {
      # Some Perl maintainers have taken to writing package decls
      # with a newline and an optional comment, to hide them from
      # the PAUSE (Perl Author Upload SErver) indexer, like so:
      #
      #  package # hide me from PAUSE
      #    Actual::Module::Name;
      $inpause = 1;
      next;
    }

    # not everyone puts the package name of the file as the first
    # package name so we report all namespaces except some common
    # false positives as if they were provided packages (really ugly).

    if (m/^\s*package\s+([_:a-zA-Z0-9]+)\s*;/
        or ($inpause and /\s*([_:a-zA-Z0-9]+)\s*;/)) {
      $package=$1;
      undef $version;
      if ($package eq 'main') {
        undef $package;
      } else {
        # If $package already exists in the $require hash, it means
        # the package definition is broken up over multiple blocks.
        # In that case, don't stomp a previous $VERSION we might have
        # found.  (See BZ#214496.)
        $require{$package}=undef unless (exists $require{$package});
      }
      $inpause = 0;
    }

    # after we found the package name take the first assignment to
    # $VERSION as the version number. Exporter requires that the
    # variable be called VERSION so we are safe.

    # here are examples of VERSION lines from the perl distribution

    #FindBin.pm:$VERSION = $VERSION = sprintf("%d.%02d", q$Revision: 1.9 $ =~ /(\d+)\.(\d+)/);
    #ExtUtils/Install.pm:$VERSION = substr q$Revision: 1.9 $, 10;
    #CGI/Apache.pm:$VERSION = (qw$Revision: 1.9 $)[1];
    #DynaLoader.pm:$VERSION = $VERSION = "1.03";     # avoid typo warning
    #General.pm:$Config::General::VERSION = 2.33;
    # 
    # or with the new "our" pragma you could (read will) see:
    #
    #    our $VERSION = '1.00'
    if (($package) && (m/^\s*(our\s+)?\$(\Q$package\E::)?VERSION\s*=\s+/)) {

      # first see if the version string contains the string
      # '$Revision' this often causes bizzare strings and is the most
      # common method of non static numbering.

      if (m/(\$Revision: (\d+[.0-9]+))/) {
	$version= $2; 
      } elsif (m/[\'\"]?(\d+[.0-9]+)[\'\"]?/) {
	
	# look for a static number hard coded in the script
	
	$version= $1; 
      }
      $require{$package}=$version;
    }
  
    # Allow someone to have a variable that defines virtual packages
    # The variable is called $RPM_Provides.  It must be scoped with 
    # "our", but not "local" or "my" (just would not make sense). 
    # 
    # For instance:
    #  
    #     $RPM_Provides = "blah bleah"
    # 
    # Will generate provides for "blah" and "bleah".
    #
    # Each keyword can appear multiple times.  Don't
    #  bother with datastructures to store these strings,
    #  if we need to print it print it now.
	
    if ( m/^\s*(our\s+)?\$RPM_Provides\s*=\s*["'](.*)['"]/i) {
      foreach $_ (split(/\s+/, $2)) {
	print "$_\n";
      }
    }

  }

  close(FILE) ||
    die("$0: Could not close file: '$file' : $!\n");

  return ;
}
__DATA__
#!/usr/bin/perl

# RPM (and its source code) is covered under two separate licenses. 

# The entire code base may be distributed under the terms of the GNU
# General Public License (GPL), which appears immediately below.
# Alternatively, all of the source code in the lib subdirectory of the
# RPM source code distribution as well as any code derived from that
# code may instead be distributed under the GNU Library General Public
# License (LGPL), at the choice of the distributor. The complete text
# of the LGPL appears at the bottom of this file.

# This alternatively is allowed to enable applications to be linked
# against the RPM library (commonly called librpm) without forcing
# such applications to be distributed under the GPL.

# Any questions regarding the licensing of RPM should be addressed to
# Erik Troan <ewt@redhat.com>.

# a simple makedepend like script for perl.
 
# To save development time I do not parse the perl grammmar but
# instead just lex it looking for what I want.  I take special care to
# ignore comments and pod's.

# It would be much better if perl could tell us the dependencies of a
# given script.

# The filenames to scan are either passed on the command line or if
# that is empty they are passed via stdin.

# If there are strings in the file which match the pattern
#     m/^\s*\$RPM_Requires\s*=\s*["'](.*)['"]/i
# then these are treated as additional names which are required by the
# file and are printed as well.

# I plan to rewrite this in C so that perl is not required by RPM at
# build time.

# by Ken Estes Mail.com kestes@staff.mail.com

if ("@ARGV") {
  foreach (@ARGV) {
    process_file($_);
  }
} else {
  
  # notice we are passed a list of filenames NOT as common in unix the
  # contents of the file.
  
  foreach (<>) {
    process_file($_);
  }
}


foreach $module (sort keys %require) {
  if (length($require{$module}) == 0) {
    print "perl($module)\n";
  } else {

    # I am not using rpm3.0 so I do not want spaces around my
    # operators. Also I will need to change the processing of the
    # $RPM_* variable when I upgrade.

    print "perl($module) >= $require{$module}\n";
  }
}

exit 0;



sub process_file {
  
  my ($file) = @_;
  chomp $file;
  
  open(FILE, "<$file") || return;
  
  while (<FILE>) {
    
    # skip the "= <<" block

    if ( ( m/^\s*(?:\S+\s+)?\$(?:.*)\s*=\s*<<\s*(["'`])(.*)\1/) ||
         ( m/^\s*(?:\S+\s+)?\$(.*)\s*=\s*<<(\w*)\s*;/) ) {
      $tag = $2;
      while (<FILE>) {
        chomp;
        ( $_ eq $tag ) && last;
      }
      $_ = <FILE>;
    }

    # skip q{} quoted sections - just hope we don't have curly brackets
    # within the quote, nor an escaped hash mark that isn't a comment
    # marker, such as occurs right here. Draw the line somewhere.
    if ( m/^.*\Wq[qxwr]?\s*([\{\(\[#|\/])[^})\]#|\/]*$/ && ! m/^\s*(require|use)\s/ ) {
      $tag = $1;
      $tag =~ tr/{\(\[\#|\//})]#|\//;
      $tag = quotemeta($tag);
      while (<FILE>) {
        ( $_ =~ m/$tag/ ) && last;
      }
    }

    # skip the documentation

    # we should not need to have item in this if statement (it
    # properly belongs in the over/back section) but people do not
    # read the perldoc.

    if ( (m/^=(head[1-4]|pod|item)/) .. (m/^=(cut)/) ) {
      next;
    }

    if ( (m/^=(over)/) .. (m/^=(back)/) ) {
      next;
    }
    
    # skip the data section
    if (m/^__(DATA|END)__$/) {
      last;
    }

    # Each keyword can appear multiple times.  Don't
    #  bother with datastructures to store these strings,
    #  if we need to print it print it now.
    #
	# Again allow for "our".
    if ( m/^\s*(our\s+)?\$RPM_Requires\s*=\s*["'](.*)['"]/i) {
      foreach $_ (split(/\s+/, $2)) {
	print "$_\n";
      }
    }

    if ( 

# ouch could be in a eval, perhaps we do not want these since we catch
# an exception they must not be required

#   eval { require Term::ReadLine } or die $@;
#   eval "require Term::Rendezvous;" or die $@;
#   eval { require Carp } if defined $^S; # If error/warning during compilation,


	(m/^(\s*)         # we hope the inclusion starts the line
	 (require|use)\s+(?!\{)     # do not want 'do {' loops
	 # quotes around name are always legal
	 [\'\"]?([^\;\ \'\"\t]*)[\'\"]?[\t\;\ ]
	 # the syntax for 'use' allows version requirements
	 \s*([.0-9]*)
	 /x)
       ) {
      my ($whitespace, $statement, $module, $version) = ($1, $2, $3,$4);

      # we only consider require statements that are flush against
      # the left edge. any other require statements give too many
      # false positives, as they are usually inside of an if statement
      # as a fallback module or a rarely used option

      ($whitespace ne "" && $statement eq "require") && next;

      # if there is some interpolation of variables just skip this
      # dependency, we do not want
      #        do "$ENV{LOGDIR}/$rcfile";
   
      ($module =~ m/\$/) && next;

      # skip if the phrase was "use of" -- shows up in gimp-perl, et al.
      next if $module eq 'of';

      # if the module ends in a comma we probaly caught some
      # documentation of the form 'check stuff,\n do stuff, clean
      # stuff.' there are several of these in the perl distribution

      ($module  =~ m/[,>]$/) && next;

      # if the module name starts in a dot it is not a module name.
      # Is this necessary?  Please give me an example if you turn this
      # back on.

      #      ($module =~ m/^\./) && next;

      # if the module ends with .pm strip it to leave only basename.
      # starts with /, which means its an absolute path to a file
      if ($module =~ m(^/)) {
        print "$module\n";
        next;
      }

      # sometimes people do use POSIX qw(foo), or use POSIX(qw(foo)) etc.
      # we can strip qw.*$, as well as (.*$:
      $module =~ s/qw.*$//;
      $module =~ s/\(.*$//;

      $module =~ s/\.pm$//;

      # some perl programmers write 'require URI/URL;' when 
      # they mean 'require URI::URL;'

      $module =~ s/\//::/;

      # trim off trailing parentheses if any.  Sometimes people pass
      # the module an empty list.

      $module =~ s/\(\s*\)$//;

      if ( $module =~ m/^v?([0-9._]+)$/ ) {
      # if module is a number then both require and use interpret that
      # to mean that a particular version of perl is specified

      my $ver=$1;
      if ($ver =~ /5.00/) {
        print "perl >= 0:$ver\n";
        next;
      }
      else {
        print "perl >= 1:$ver\n";
        next;
      }

      };

      # ph files do not use the package name inside the file.
      # perlmodlib documentation says:
      
      #       the .ph files made by h2ph will probably end up as
      #       extension modules made by h2xs.
      
      # so do not expend much effort on these.


      # there is no easy way to find out if a file named systeminfo.ph
      # will be included with the name sys/systeminfo.ph so only use the
      # basename of *.ph files

      ($module  =~ m/\.ph$/) && next;

      $require{$module}=$version;
      $line{$module}=$_;
    }
    
  }

  close(FILE) ||
    die("$0: Could not close file: '$file' : $!\n");
  
  return ; 
}
__DATA__
